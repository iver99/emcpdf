import java.nio.file.*
import java.security.MessageDigest
import java.util.regex.Pattern
import org.apache.tools.ant.filters.ReplaceTokens
import java.text.SimpleDateFormat
import java.util.Date

apply from: 'test.gradle'
apply plugin: 'war'
apply plugin: 'eclipse-wtp'
apply plugin: 'compass'

jsversion = project.ext.getServiceVersion('OMC-UI-Framework')
def versionPathElement = jsversion + "-"+ new SimpleDateFormat("yyMMdd.HHmmss").format(new Date())

sourceCompatibility = 1.7
targetCompatibility = 1.7

// source 'webapp' directory
def File sourceWebappDir = new File(project.projectDir, 'public_html')

// source directories where jet, ckeditor, font-awesome files are copied
def File sourceJetDestDir = new File(sourceWebappDir, 'libs/@version@/js/oraclejet')
//def File sourceCKeditorDesDir = new File(sourceWebappDir, 'libs/@version@/js/ckeditor')
def File sourceFontDestDir = new File(sourceWebappDir, 'libs/@version@/css/font-awesome')

// folders for minify, fingereprint js files
def stagingDir = buildDir.absolutePath+'/staging/public_html'
def compiledDir = buildDir.absolutePath+'/public_html'
def webRootSourceDir = 'public_html'

configurations {
    restDoc { transitive = false }
    
    ftpAntTask { transitive = false }

    compass
    jscover { transitive = false }
}

dependencies {
        providedCompile project(':dashboards-ui:dashboardsui-webutils'){ transitive = false }
        compile(group: 'org.apache.logging.log4j', name:'log4j-core', version:'2.0.2'){ transitive = false }
        compile(group: 'org.apache.logging.log4j', name:'log4j-api', version:'2.0.2'){ transitive = false }
        compile(group: 'com.oracle.emaas.emcpsm', name: 'registry-lookup-client', version: '1.+'){ transitive = false }
        compile(group: 'com.oracle.emaas.emcpsm', name: 'registry-client', version: '1.+'){ transitive = false }
    	providedCompile(group: 'org.codehaus.groovy', name:'groovy-all', version:'2.2.1'){ transitive = false }
   
 	providedCompile(group: 'commons-codec', name:'commons-codec', version:'1.6') { transitive = false }
    	providedCompile(group: 'org.apache.commons', name:'commons-lang3', version:'3.1') { transitive = false }
    	providedCompile(group: 'commons-logging', name:'commons-logging', version:'1.1.1') { transitive = false }
    	providedCompile(group: 'org.apache.httpcomponents', name:'httpclient', version:'4.3.1') { transitive = false }
        providedCompile(group: 'org.apache.httpcomponents', name:'httpcore', version:'4.3') { transitive = false }
        providedCompile(group: 'org.apache.httpcomponents', name:'httpmime', version:'4.3.1') { transitive = false }
  
    	
        providedCompile(group: 'javax.servlet', name:'servlet-api', version:'2.5'){ transitive = false }
        providedCompile(group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.0'){ transitive = false }
        
	compile(group: 'com.oracle.oraclejet', name: 'oraclejet', version: '2.0.1-24669', ext: 'war'){ transitive = false }
	//compile(group: 'CKSource', name: 'ckeditor_full', version: '4.5.1', ext: 'zip'){transitive = false}
	compile(group: 'com.font-awesome', name: 'font-awesome', version: '4.3.0', ext: 'zip') {transitive = false }
        compile(group: 'org.jmockit', name: 'jmockit', version: '1.19') { transitive = false }
    
	ftpAntTask('org.apache.ant:ant-commons-net:12.1.2-0-0') {
	        module('commons-net:commons-net:1.4.1') {
	                dependencies 'oro:oro:2.0.8:jar'
        	}
    	}

	compass (group: 'org.jruby', name: 'jruby-complete', version: '1.7.3')
	jscover (group:'com.github.tntim96', name:'JSCover-all', version:'1.0.19')
}

def jscc = "1".equals(System.getenv()['ENABLE_CC_JS'])

//javascript code coverage

//define the JS source locations
javascript.source {
    dev {
            js {
                srcDir 'public_html/@version@/js'
                include "**/*.js"
            }
        }
    cachedjs {
        js {
        srcDir 'public_html/@version@/js'
        include "**/*.js"
	exclude "**/builder.jet.partition.js"
        exclude "*.js"
        exclude "**/*.orig.js"
        }
    }
    jshint {
	js {
		srcDir 'public_html'
                include "**/*.js"
	}
    }
}

task cleanJs(type:Delete) {
    delete fileTree(dir: stagingDir)
    delete fileTree(dir: compiledDir)
}

//unpack JET
project.task("unpackJETFromArtifactory") << {
    def File buildJetUnzipDir = new File(buildDir.absolutePath, 'jet')
    //first time or if custom cleans removes it
    sourceJetDestDir.mkdirs()

    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        if (artifact.name.equals('oraclejet') && files(sourceJetDestDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            buildJetUnzipDir.mkdirs()
            project.copy {
                from project.zipTree(artifact.file.absolutePath)
                into buildJetUnzipDir.absolutePath
            }
	    project.copy {
		from  buildJetUnzipDir
		into sourceJetDestDir.absolutePath
	    }
            if(!project.hasProperty("devMode")){
		def outputDir = file(stagingDir+"/libs/"+versionPathElement+"/js/oraclejet");
		outputs.dir outputDir
		project.copy {
		    from  buildJetUnzipDir
		    into outputDir
		}
	    }
            project.delete(buildJetUnzipDir)
        }
    }
}

project.task("cleanJet") << {
    println 'Cleaning up jet directories ...'
    println 'oraclejet dir: ' + sourceJetDestDir.absolutePath
    sourceJetDestDir.deleteDir()
}

project.task("unpackFontFromArtifactory") << {    
    def File buildFontUnzipDir = new File(buildDir.absolutePath, 'font-awesome')
    //first time or if custom cleans removes it
    sourceFontDestDir.mkdirs()

    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        if (artifact.name.equals('font-awesome') && files(sourceFontDestDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            buildFontUnzipDir.mkdirs()
            project.copy {  
		from project.file(artifact.file.absolutePath)
		into buildFontUnzipDir.absolutePath
	    }
	    
	    ant.unzip(src: buildFontUnzipDir.absolutePath+"/font-awesome-4.3.0.zip", dest:buildFontUnzipDir.absolutePath)

	    project.copy {
	    	    from buildFontUnzipDir.absolutePath+"/font-awesome-4.3.0"
		    into sourceFontDestDir.absolutePath
	    }
	
     	    if(!project.hasProperty("devMode")){
	        def outputDir = file(stagingDir+"/libs/"+versionPathElement+"/css/font-awesome");
	        outputs.dir outputDir
	        project.copy {
		    from sourceFontDestDir.absolutePath
		    into outputDir
	        }
	    }	
	    project.delete(buildFontUnzipDir)
        }
    }
}

project.task("cleanFont") << {
    println 'Cleaning up font directories ...'
    println 'font-awesome dir: ' + sourceFontDestDir.absolutePath
    sourceFontDestDir.deleteDir()
}

task copyJsSource(type:Copy, dependsOn:[cleanJs, compileSass]) {//unpackJETFromArtifactory, unpackJSLibFromArtifactory,unpackFontFromArtifactory,compileSass]) {

    from (webRootSourceDir) {
        include "**/*"
            eachFile {
                fileCopyDetails ->
                fileCopyDetails.path = fileCopyDetails.path.replaceAll(/(.*\/|.*)@version@\/(.*)/, '$1/'+versionPathElement+'/$2')
                fileCopyDetails.name = fileCopyDetails.name.replaceAll(/(.*)@version@(.*)/, '$1'+versionPathElement+'$2')
            }
            //replace @version@ with versionPathElement
            filesMatching("**/*.js") {               
            filter(ReplaceTokens, tokens: [version: versionPathElement])
            }
            filesMatching("**/*.html") {
                filter(ReplaceTokens, tokens: [version: versionPathElement])
            }
	    filesMatching("**/*.css") {
                filter(ReplaceTokens, tokens: [version: versionPathElement])
            }
	    
//            filesMatching("**/dashboards-home-alta.css") {
//                filter(ReplaceTokens, tokens: [version: versionPathElement])
//            }
//            filesMatching("**/dashboards-common-alta.css") {
//                filter(ReplaceTokens, tokens: [version: versionPathElement])
//            }
//            filesMatching("**/builder-alta.css") {
//                filter(ReplaceTokens, tokens: [version: versionPathElement])
//            }
//            filesMatching("**/landing-home-alta.css") {
//                filter(ReplaceTokens, tokens: [version: versionPathElement])
//            }
    }
    into stagingDir

    doLast {
       //this is here because of gradle bug, the old @version@ directory remains
	    delete stagingDir+'/@version@'
	    delete stagingDir+'/libs/@version@'
	    //delete webRootSourceDir+'/@version@/css'
    }
}

task stageJs(dependsOn:[unpackJETFromArtifactory,unpackFontFromArtifactory,copyJsSource]) {//, unpackJSLibFromArtifactory
}

clean.dependsOn cleanJet, cleanJs, cleanFont//cleanJSLib,

task jsCodeCoverage(type:JavaExec, dependsOn:[cleanJs, stageJs]){//copyJsSource]) {

    //vmArgs '-Dfile.encoding=UTF-8'
    main '-jar'
    configurations.jscover.resolvedConfiguration.resolvedArtifacts.each { artifact ->
	logger.lifecycle("filepath:  "+artifact.name)
        if (artifact.name.equals('JSCover-all')) {
		logger.lifecycle("filepath"+artifact.file.absolutePath)
		//args artifact.file.absolutePath, '-fs', '--local-storage', '--no-instrument-reg=.*\\/js\\/util\\/.*','--no-instrument-reg=.*\\/ckeditor\\/.*', '--no-instrument-reg=.*\\/oraclejet\\/.*',stagingDir, buildDir.absolutePath+'/staging/public_htmlcc'
		args artifact.file.absolutePath, '-fs', '--local-storage', '--no-instrument-reg=.*\\/d3\\/.*', '--no-instrument-reg=.*\\/canvg\\/.*', '--no-instrument-reg=.*\\/html2canvas\\/.*', '--no-instrument-reg=.*\\/oraclejet\\/.*', '--no-instrument-reg=.*\\/ita-tool\\/.*', '--no-instrument-reg=.*\\/js\\/jquery\\/.*', '--no-instrument-reg=.*\\/js\\/resources\\/nls\\/root\\/uifwkCommonMsg.js',stagingDir, buildDir.absolutePath+'/staging/public_htmlcc'
            }
	}      
    
    doLast {
        //delete uninstrumented source
        //delete stagingDir+'/js'
	delete stagingDir
        //rename instrumented source to source folder
        //file(stagingDir+'/jscc').renameTo(file(stagingDir+'/js'))
	file(buildDir.absolutePath+'/staging/public_htmlcc').renameTo(file(stagingDir))
        //now zip up original-src so we can download and generate reports
        //ant.zip(destfile: stagingDir+'/js/original-src.zip',basedir: stagingDir+'/js/original-src/');
	ant.zip(destfile: stagingDir+'/original-src.zip',basedir: stagingDir+'/original-src/');
   }
}
jsCodeCoverage.onlyIf{jscc}

/**
 * combine -> minify -> fingerprint JavaScript
 */

task copyStagedJs(type:Copy, dependsOn:[stageJs]){//[copyJsSource]) {
    from (stagingDir) {
	include "**/*"	
    }
    into compiledDir
}

javascript.source.cachedjs.js.files.eachWithIndex { File jsFile, idx ->
    tasks.add(name: "dominifycachejs${idx}", type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    String fileName = "${jsFile.name}"
    String renamedFile = fileName.replace(".",".orig.")
    def parentDir = jsFile.parent
    def tmpFolder= parentDir.split("js") as String[]
    def sourceFile = "";
    def destFile = "";
    def tmp ="";

    if ( parentDir.endsWith("/js")){
        for(int i=1; i<tmpFolder.length;i++){
            tmp=tmp+'js'+tmpFolder[i]
        }
        sourceFile = compiledDir+"/"+versionPathElement+"/"+tmp+"/js/"+fileName
        destFile = compiledDir+"/"+versionPathElement+"/"+tmp+"/js/"+renamedFile
    }
    else
    {
        for(int i=1; i<tmpFolder.length;i++){
            tmp=tmp+'js'+tmpFolder[i]
        }
        sourceFile = compiledDir+"/"+versionPathElement+"/"+tmp+"/"+fileName
        destFile = compiledDir+"/"+versionPathElement+"/"+tmp+"/"+renamedFile
    }
    
    doFirst{ 
        Files.copy(Paths.get(sourceFile),Paths.get(destFile))
    }

        source = sourceFile
    dest = sourceFile
    String sourceMapFile = fileName.replace(".js",".map")
    if ( parentDir.endsWith("/js") )
    {
        sourceMap = file(compiledDir+"/"+versionPathElement+"/"+tmp+"/js/"+sourceMapFile)
    }
    else
    {
        sourceMap = file(compiledDir+"/"+versionPathElement+"/"+tmp+"/"+sourceMapFile)
    }
    
    closure {
            warningLevel = 'QUIET'
    }

    doLast {
        //update the compiled JS to point to the source map
        File compiledFile = new File(sourceFile)
        compiledFile.append("\n//# sourceMappingURL="+sourceMapFile, 'UTF-8')       

        //fix file path in source map file
        File mapFile = compiledFile
        if ( parentDir.endsWith("/js") )
        {
                 mapFile = new File(compiledDir+"/"+versionPathElement+"/"+tmp+"/js/"+sourceMapFile)
        }
        else
        {
                mapFile = new File(compiledDir+"/"+versionPathElement+"/"+tmp+"/"+sourceMapFile)
        }
        
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile
        contents = contents.replaceAll(Pattern.quote(absPath), renamedFile)
        mapFile.write(contents, 'UTF-8')
        }   
    }
}

task individualUtilMinify(dependsOn:[copyStagedJs, tasks.matching { Task task -> task.name.startsWith("dominify")}])

task prepareRequireJsConfig(type:Copy) {
    from ('.') {
        include "dashboard.build.js"
            //replace @version@ with versionPathElement
            filter(ReplaceTokens, tokens: [version: versionPathElement])
    }
    into buildDir
}

task combineAppJs(dependsOn: [jsCodeCoverage,copyStagedJs,prepareRequireJsConfig], type: com.eriwen.gradle.js.tasks.RequireJsTask) {
    source = javascript.source.dev.js.files   //point to your source files
    requirejs.buildprofile = file(buildDir.absolutePath+"/dashboard.build.js")
    outputs.upToDateWhen { false }           //requireJs task does not know how to accurately determine if it is UP-TO-DATE so this line says the task is never up to date.
}

task jsHint(type:com.eriwen.gradle.js.tasks.JsHintTask){
        source = javascript.source.jshint.js.files
        dest = file(buildDir.absolutePath+'/jshint.out')
        reporter = 'checkstyle'
        jshint.options = [expr: "true", unused: "true", sub: "true"]
        jshint.predef = [define: 1, require:2, requirejs:3, window:4, document:5, setTimeout:6, console:7, d3:8, $: 9, canvg:10, html2canvas:11, clearTimeout: 12, Promise: 13, setInterval: 14, importScripts:15, Worker: 16, postMessage: 17, btoa: 18, escape: 19, unescape: 20, atob: 21, Storage: 22]
}

//generateMD5 is a helper method which will generate an MD5 string for a given file
def generateMD5(String s) {
    MessageDigest digest = MessageDigest.getInstance("MD5")
    digest.update(s.bytes);
    new BigInteger(1, digest.digest()).toString(16).padLeft(32, '0').toString()
}

//minifyJs runs the google closure compiler.  Addtionally the doFirst and doLast will fingerprint and set up HTML 5 source maps for your code

task minifyWelcomeJs(dependsOn: [individualUtilMinify, combineAppJs],type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    doFirst {
        //copy the original source which will be used in a source map
        Files.copy(Paths.get(compiledDir+"/"+versionPathElement+'/js/welcomeMain.js'), Paths.get(compiledDir+"/"+versionPathElement+'/js/welcomeMain.orig.js'))
    }
    source = file(compiledDir+"/"+versionPathElement+'/js/welcomeMain.js')
    dest = file(compiledDir+"/"+versionPathElement+'/js/welcomeMain.js')
    sourceMap = file(compiledDir+"/"+versionPathElement+'/js/welcomeMain.map')

    closure {
        warningLevel = 'QUIET'
    }

    doLast {
    //update the compiled JS to point to the source map
        File compiledFile = new File(compiledDir+"/"+versionPathElement+'/js/welcomeMain.js')
    logger.lifecycle("compiledFile:" + compiledFile.absolutePath)
        compiledFile.append("\n//# sourceMappingURL=welcomeMain.map", 'UTF-8')

       //generate a fingerprint
        String md5 = generateMD5(compiledFile.getText('UTF-8'))
        compiledFile.renameTo(compiledDir+"/"+versionPathElement+'/js/welcomeMain-'+md5+'.js')

       //update references to point to fingerprinted file
        File htmlFile = new File(compiledDir+'/welcome.html')
        String html = htmlFile.getText('UTF-8')
        html = html.replaceAll(Pattern.quote('js/welcomeMain'), 'js/welcomeMain-'+md5)
        htmlFile.write(html, 'UTF-8')

        //fix file path in source map file
        File mapFile = new File(compiledDir+"/"+versionPathElement+'/js/welcomeMain.map')
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile;
        contents = contents.replaceAll(Pattern.quote(absPath), 'welcomeMain.orig.js')
        mapFile.write(contents, 'UTF-8')
    }
}

task minifyBuilderJs(dependsOn: [minifyWelcomeJs],  type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    doFirst {
        //copy the original source which will be used in a source map
    Files.copy(Paths.get(compiledDir+"/"+versionPathElement+'/js/builderMain.js'), Paths.get(compiledDir+"/"+versionPathElement+'/js/builderMain.orig.js'))
    }
    source = file(compiledDir+"/"+versionPathElement+'/js/builderMain.js')
    dest = file(compiledDir+"/"+versionPathElement+'/js/builderMain.js')
    sourceMap = file(compiledDir+"/"+versionPathElement+'/js/builderMain.map')

    closure {
        warningLevel = 'QUIET'
    }

    doLast {
    //update the compiled JS to point to the source map
        File compiledFile = new File(compiledDir+"/"+versionPathElement+'/js/builderMain.js')
    logger.lifecycle("compiledFile:" + compiledFile.absolutePath)
        compiledFile.append("\n//# sourceMappingURL=builderMain.map", 'UTF-8')

       //generate a fingerprint
        String md5 = generateMD5(compiledFile.getText('UTF-8'))
        compiledFile.renameTo(compiledDir+"/"+versionPathElement+'/js/builderMain-'+md5+'.js')

       //update references to point to fingerprinted file
        File htmlFile = new File(compiledDir+'/builder.html')
        String html = htmlFile.getText('UTF-8')
        html = html.replaceAll(Pattern.quote('js/builderMain'), 'js/builderMain-'+md5)
        htmlFile.write(html, 'UTF-8')

        //fix file path in source map file
        File mapFile = new File(compiledDir+"/"+versionPathElement+'/js/builderMain.map')
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile;
        contents = contents.replaceAll(Pattern.quote(absPath), 'builderMain.orig.js')
        mapFile.write(contents, 'UTF-8')
    }
}

task minifyHomeJs(dependsOn: [minifyBuilderJs], type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    doFirst {
        //copy the original source which will be used in a source map
        Files.copy(Paths.get(compiledDir+"/"+versionPathElement+'/js/homeMain.js'), Paths.get(compiledDir+"/"+versionPathElement+'/js/homeMain.orig.js'))
    }
    source = file(compiledDir+"/"+versionPathElement+'/js/homeMain.js')
    dest = file(compiledDir+"/"+versionPathElement+'/js/homeMain.js')
    sourceMap = file(compiledDir+"/"+versionPathElement+'/js/homeMain.map')

    closure {
        warningLevel = 'QUIET'
    }

    doLast {
    //update the compiled JS to point to the source map
        File compiledFile = new File(compiledDir+"/"+versionPathElement+'/js/homeMain.js')
    logger.lifecycle("compiledFile:" + compiledFile.absolutePath)
        compiledFile.append("\n//# sourceMappingURL=homeMain.map", 'UTF-8')

       //generate a fingerprint
        String md5 = generateMD5(compiledFile.getText('UTF-8'))
        compiledFile.renameTo(compiledDir+"/"+versionPathElement+'/js/homeMain-'+md5+'.js')

       //update references to point to fingerprinted file
        File htmlFile = new File(compiledDir+'/home.html')
        String html = htmlFile.getText('UTF-8')
        html = html.replaceAll(Pattern.quote('js/homeMain'), 'js/homeMain-'+md5)
        htmlFile.write(html, 'UTF-8')

        //fix file path in source map file
        File mapFile = new File(compiledDir+"/"+versionPathElement+'/js/homeMain.map')
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile;
        contents = contents.replaceAll(Pattern.quote(absPath), 'homeMain.orig.js')
        mapFile.write(contents, 'UTF-8')
    }
}

compass {
    // We package the gems into the .jar file (see compass dependencies)
    // so that http proxy issues do not affect us.  To enable this, 
    // we also build our own plugin for use.
    gemPath = file('build/.jruby/gems')
    gemJars = ['compass-gems:compass-gems:1.0.1']
    gems = []
    //if(project.hasProperty("devMode")){
	cssDir file('public_html/@version@/css')
    //}
    //else{
//	cssDir file('build/staging/public_html/'+versionPathElement+'/css')
  //  }
    sassDir file ('public_html/scss')
    debugInfo false // Defaults to true,
                    // set to false to remove debug info from generated css file
    noLineComments true
    force true
}

compileSass {
     jvmArgs '-Xmx2048M'
}

task runQAUITestSuite(type: Test){
        useTestNG(){
        dependsOn ':dashboards-ui:dashboardsui-ee:ear'
        useDefaultListeners = true
        outputDirectory = file("$buildDir/testngoutput")
        suites file('testngsuite.xml')
        }
}

// Directory where the restful API doc is generated
ext.restDocRootDir = "${buildDir}/restdoc" 
ext.restDocOutputDir = "${restDocRootDir}"

/**
 * Generates documentation for the REST service API
 */  
task restDoc {
 
    // Configure task input and output to not generate the doc again when the 
    // source file have not changed
    inputs.files 'src/main/java/oracle/sysman/emaas/platform/dashboards/ui/web/rest'
    outputs.dir restDocOutputDir
}




//copy files without any convert when -PdevMode enabled
task copyDevJs(type:Copy, dependsOn: [cleanJs, unpackJETFromArtifactory,unpackFontFromArtifactory,compileSass]){//, unpackJSLibFromArtifactory
    from('public_html') {
	include "**/*"
    }
    into compiledDir
    
    doLast {
        delete 'public_html/@version@/css'
    }    
}
test {
        useTestNG()
        {
                //We explicity include only tests annotate as s1 or s2 - they are "short-running" tests,
                //if you wish to run ALL tests within this projet - remove following.
                includeGroups 's1' ,'s2'
        }
}

war.archiveName "dashboardsui-web.war"
war {
	if(project.hasProperty("devMode")){
	    from(compiledDir) {
		include '**/*'
		exclude '**/*.orig.js','**/*.map'
		into('/')
	    }
	    from('src/main/java') { 
		include '**/*.properties'
		into('WEB-INF/classes') 
	    }
	}
	else{
	    from(compiledDir) {
		include '**/*'
		exclude '**/*.orig.js','**/*.map','**/scss'
		into('/')
	    }
	    from('src/main/java') { 
		include '**/*.properties'
		into('WEB-INF/classes') 
	    }
	}
    //rootSpec.exclude("**/*.zip")
}

if(project.hasProperty("devMode")){
    war.dependsOn copyDevJs
}
else
{
    war.dependsOn minifyHomeJs
}
publishing.publications {
        integTest(MavenPublication) {
                setArtifactId(project.name + '-' + integTestJar.appendix)
                setGroupId("${publishGroup}")
                artifact integTestJar.archivePath
        }

        thisJarPublication(MavenPublication) {
                setGroupId("${publishGroup}")
                artifact jar
        }
}

artifactoryPublish {
        publications('integTest')
        publications('thisJarPublication')
}

