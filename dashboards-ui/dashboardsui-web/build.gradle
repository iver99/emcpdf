import java.nio.file.*
import java.security.MessageDigest
import java.util.regex.Pattern

apply plugin: 'war'
apply plugin: 'maven-publish'
apply plugin: 'artifactory-publish'

group = 'com.oracle.emaas.emcpdf'
version = '1.1'

sourceCompatibility = 1.7
targetCompatibility = 1.7


// source 'webapp' directory
def File sourceWebappDir = new File(project.projectDir, 'public_html')
// source directories where jet, canvg, canvas files are copied
def File sourceJetDestDir = new File(sourceWebappDir, 'emcsDependencies/oraclejet')
def File sourceJsCanvgDestDir = new File(sourceWebappDir, 'emcsDependencies/canvg')
def File sourceJsCanvasDesDir = new File(sourceWebappDir, 'emcsDependencies/html2canvas')
// 
def stagingDir = buildDir.absolutePath+'/staging/public_html'
def compiledDir = buildDir.absolutePath+'/public_html'
def File sourceDFCommonDestDir = new File(sourceWebappDir, 'emcsDependencies/dfcommon')

configurations {
	restDoc { transitive = false }
	enunciateCore { transitive = false }
	ftpAntTask { transitive = false }
}

//define the JS source locations
javascript.source {
	dev {
            js {
                srcDir 'public_html'
                include "**/*.js"
            }
        }
 }

task cleanJs(type:Delete) {
	delete fileTree(dir: stagingDir)
        delete fileTree(dir: compiledDir)
}

task copyJsSource(type:Copy, dependsOn:[cleanJs]) {
    from ('public_html') {
	include "**/*"
    }
    into stagingDir
}

project.task("unpackJETFromArtifactory") << {
    // if the resources/web/js/libs directory is empty - either the first time this task is
    // run or the directory has been cleaned, then
    // iterate over the project artifacts and look for the oraclejet.zip,
    // - downloaded on the local file system (generally found in <user_home_dir>/.gradle)
    // - unzip to the build/jet directory
    // - copy over the directories to different common/resources directories
    // (these directories are specified in the .gitignore file)
    // - delete the build/jet directory
    // build directory where the oraclejet.zip will be unzipped
    
    def File buildJetUnzipDir = new File(buildDir.absolutePath, 'jet')
    //first time or if custom cleans removes it
    sourceJetDestDir.mkdirs()

    //project.configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        if (artifact.name.equals('oraclejet') && files(sourceJetDestDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            buildJetUnzipDir.mkdirs()
            project.copy {
                from project.zipTree(artifact.file.absolutePath)
                into buildJetUnzipDir.absolutePath
            }
            // Copy each of the unzipped jet directories to
            // the appropriate source directories
            // 1. build/jet/ >> public_html/emcsDependencies/oraclejet/
            project.copy {
                from  buildJetUnzipDir
                into sourceJetDestDir.absolutePath
            }
            
            //finally delete the build/jet directory
            project.delete(buildJetUnzipDir)
        }
    }
}

project.task("cleanJet") << {
    println 'Cleaning up jet directories ...'
    println 'oraclejet dir: ' + sourceJetDestDir.absolutePath
    sourceJetDestDir.deleteDir()
}


//unpack js libs from artifactory
project.task("unpackJSLibFromArtifactory") << {
    def File buildJsCanvgUnzipDir = new File(buildDir.absolutePath, 'canvg')
    def File buildJsCanvasUnzipDir = new File(buildDir.absolutePath, 'html2canvas')
    //first time or if custom cleans removes it
    sourceJsCanvgDestDir.mkdirs()
    sourceJsCanvasDesDir.mkdirs()

    //project.configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        if (artifact.name.equals('canvg') && files(sourceJsCanvgDestDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            sourceJsCanvgDestDir.mkdirs()
            project.copy {
                from project.zipTree(artifact.file.absolutePath)
                into buildJsCanvgUnzipDir.absolutePath
            }
            // Copy each of the unzipped jet directories to
            // the appropriate source directories
            // 1. build/canvg/ >> public_html/emcsDependencies/canvg/
            project.copy {
                from  buildJsCanvgUnzipDir
                into sourceJsCanvgDestDir.absolutePath
            }
            
            //finally delete the build/jet directory
            project.delete(buildJsCanvgUnzipDir)
        }

	if (artifact.name.equals('html2canvas') && files(sourceJsCanvasDesDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            sourceJsCanvasDesDir.mkdirs()
            project.copy {
                from artifact.file.absolutePath
                into buildJsCanvasUnzipDir.absolutePath
            }
            // Copy each of the unzipped jet directories to
            // the appropriate source directories
            // 1. build/canvg/ >> public_html/emcsDependencies/canvg/
            project.copy {
                from  buildJsCanvasUnzipDir
                into sourceJsCanvasDesDir.absolutePath
		rename 'html2canvas-(.+)', 'html2canvas.js'
            }
            
            //finally delete the build/jet directory
            project.delete(buildJsCanvasUnzipDir)
        }
    }
}

project.task("cleanJSLib") << {
    println 'Cleaning up JS lib directories ...'
    println 'JS lib canvg dir: ' + sourceJsCanvgDestDir.absolutePath
    sourceJsCanvgDestDir.deleteDir()
    println 'JS lib html2canvas dir : ' + sourceJsCanvasDesDir.absolutePath
    sourceJsCanvasDesDir.deleteDir()
}

project.task("unpackDFCommonFromArtifactory") << {
    
    def File buildDFCommonUnzipDir = new File(buildDir.absolutePath, 'dfcommon')
    //first time or if custom cleans removes it
    sourceDFCommonDestDir.mkdirs()

    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        if (artifact.name.equals('emcs-ui-framework-common-dev') && files(sourceDFCommonDestDir.listFiles()).isEmpty()) {
            logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
            buildDFCommonUnzipDir.mkdirs()
            project.copy {
                from project.zipTree(artifact.file.absolutePath)
                into buildDFCommonUnzipDir.absolutePath
            }
            // Copy each of the unzipped jet directories to
            // the appropriate source directories
            // 1. build/dfcommon/ >> public_html/emcsDependencies/dfcommon/
            project.copy {
                from  buildDFCommonUnzipDir.absolutePath+'/dfcommon'
                into sourceDFCommonDestDir.absolutePath
            }
            
            //finally delete the build/dfcommon directory
            project.delete(buildDFCommonUnzipDir)
        }
    }
}

project.task("cleanDFCommon") << {
    println 'Cleaning up dfcommon directories ...'
    println 'dfcommon dir: ' + sourceDFCommonDestDir.absolutePath
    sourceDFCommonDestDir.deleteDir()
}

//unpack the integ common libs from artifactory
def war_number = "${download_number}"
def download_group = "${download_group}".split(",")
def download_artifacts = "${download_artifacts}".split(",")
def download_version = "${download_version}".split(",")
def download_foldername = "${download_foldername}".split(",")

project.task("unpackZipFromArtifactory") << {
    
    for (i in 0..<war_number.toInteger()){
	    configurations.compile.resolvedConfiguration.resolvedArtifacts.each { artifact ->
		if (artifact.name.contains(download_artifacts[i])) {
		    logger.lifecycle("Unpacking artifact ${artifact.name}, version:${artifact.moduleVersion.id.version}..")
		    def File buildWarUnzipDir = new File(buildDir.absolutePath, "intgwar"+i)
		    buildWarUnzipDir.mkdirs()
		    project.copy {
		        from project.file(artifact.file.absolutePath)
		        into buildWarUnzipDir.absolutePath
		    }
		    ant.unzip(src: buildWarUnzipDir.absolutePath+"/"+download_artifacts[i]+"-"+download_version[i]+".zip", dest:buildWarUnzipDir.absolutePath)
		    
		    project.copy {
		        //from  buildWarUnzipDir.absolutePath+"/emcsDependencies/"
			from buildWarUnzipDir.absolutePath
			exclude "*.zip"
		        into sourceWebappDir.absolutePath+"/emcsDependencies/"
		    }
		    
		    project.delete(buildWarUnzipDir)
		}
	    }
    }
}

project.task("cleanZip") << {
    def File warDestDir = new File(sourceWebappDir.absolutePath,"/emcsDependencies")
    def File tmpdir = warDestDir
    println 'Cleaning up war directories ...'

    download_foldername.each { folder ->
        tmpdir = new File(warDestDir.absolutePath,"/"+folder)
	println 'war dir: ' + tmpdir
	tmpdir.deleteDir()
	}
}

clean.dependsOn cleanJet,cleanZip,cleanDFCommon,cleanJSLib, cleanJs

task stageJs(dependsOn: copyJsSource){
}

if(war_number.toInteger()>0){
	copyJsSource.dependsOn unpackJETFromArtifactory, unpackDFCommonFromArtifactory,unpackJSLibFromArtifactory, unpackZipFromArtifactory
}
else
{
	copyJsSource.dependsOn unpackJETFromArtifactory, unpackDFCommonFromArtifactory,unpackJSLibFromArtifactory
}

task runQAUITestSuite(type: Test){
        useTestNG(){
        dependsOn ':dashboards-ui:dashboardsui-ee:ear'
        useDefaultListeners = true
        outputDirectory = file("$buildDir/testngoutput")
        suites file('testngsuite.xml')
        }
}

// Directory where the restful API doc is generated
ext.restDocRootDir = "${buildDir}/restdoc" 
ext.restDocOutputDir = "${restDocRootDir}"

/**
 * Generates documentation for the REST service API
 */  
task restDoc {
 
    // Configure task input and output to not generate the doc again when the 
    // source file have not changed
    inputs.files 'src/main/java/oracle/sysman/emaas/platform/dashboards/ui/web/rest'
    outputs.dir restDocOutputDir
}
restDoc << {
    
    // Declare the enunciate ant task
    ant.taskdef (name: 'enunciate', 
        classname: 'org.codehaus.enunciate.main.EnunciateTask',
        classpath: configurations.enunciateCore.asPath)
    
    // Make the directory to store enunciate output
    ant.mkdir(dir: "${restDocOutputDir}")

    // Define classpath for running enunciate
    ant.path(id:'enunciateRuntimePath') {
        pathelement(path: configurations.restDoc.asPath)
    }  

    // Run the enunciate task
    ant.enunciate(basedir: 'src/main/java/oracle/sysman/emaas/platform/dashboards/ui/web/rest/',
            classpathRef: 'enunciateRuntimePath',
            verbose: 'true', 
            debug: 'true', 
            configFile: 'enunciate.xml',
            javacSourceVersion: '7') {
        
        include(name: '**/*.java')
	exclude(name: '*/exception')
        export(artifactId: 'docs', destination: restDocOutputDir)
        javacArgument(argument: '-g')
    }	
}

/**
 * FTP the REST API document to the ftp server
 */

task ftpRestDoc << {
		ant {
			taskdef(name: 'ftp',
                classname: 'org.apache.tools.ant.taskdefs.optional.net.FTP',
                classpath: configurations.ftpAntTask.asPath)
			ftp(server: ftpserver, userid: uidoc_username, password: uidoc_password, remotedir: remote_restdoc_dir) {
				fileset(dir: "${restDocOutputDir}")
			}
		}
	}

sourceSets {
                            test{
                                java {
                                          srcDirs = ['src/test/java']
                                }
                                resources.srcDirs = ['src/test/java']
                            }
 }


/**
 * combine -> minify -> fingerprint JavaScript
 */


//requireJs task combines JS using the requireJS compiler


task copyStagedJs(type:Copy, dependsOn:[cleanJs, stageJs]) {
    from (stagingDir) {
	include "**/*"
    }
    into compiledDir
}

requireJs {
    source = javascript.source.dev.js.files   //point to your source files
    requirejs.buildprofile = file("dashboard.build.js") //this is where you configure the r.js compiler.  See this page for information on how to configure the r.js compiler.  This is what we do in target analytics.
    outputs.upToDateWhen { false }           //requireJs task does not know how to accurately determine if it is UP-TO-DATE so this line says the task is never up to date.
}

requireJs.dependsOn stageJs                 //stageJs sets up the JS directory structure in the build area.  The implementation will be specific to your application/build

//generateMD5 is a helper method which will generate an MD5 string for a given file
def generateMD5(String s) {
    MessageDigest digest = MessageDigest.getInstance("MD5")
    digest.update(s.bytes);
    new BigInteger(1, digest.digest()).toString(16).padLeft(32, '0').toString()
}

//minifyJs runs the google closure compiler.  Additionally the doFirst and doLast will fingerprint and set up HTML 5 source maps for your code
task minifyBuilderJs(dependsOn: requireJs, type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    doFirst {
        //copy the original source which will be used in a source map
	Files.copy(Paths.get(compiledDir+'/js/builderMain.js'), Paths.get(compiledDir+'/js/builderMain.orig.js'))
    }
    source = file(compiledDir+'/js/builderMain.js')
    dest = file(compiledDir+'/js/builderMain.js')
    sourceMap = file(compiledDir+'/js/builderMain.map')

    closure {
        warningLevel = 'QUIET'
    }

    doLast {
	//update the compiled JS to point to the source map
        File compiledFile = new File(compiledDir+'/js/builderMain.js')
	logger.lifecycle("compiledFile:" + compiledFile.absolutePath)
        compiledFile.append("\n//# sourceMappingURL=builderMain.map", 'UTF-8')

       //generate a fingerprint
        String md5 = generateMD5(compiledFile.getText('UTF-8'))
        compiledFile.renameTo(compiledDir+'/js/builderMain-'+md5+'.js')

       //update references to point to fingerprinted file
        File htmlFile = new File(compiledDir+'/builder.html')
        String html = htmlFile.getText('UTF-8')
        html = html.replaceAll(Pattern.quote('js/builderMain'), 'js/builderMain-'+md5)
        htmlFile.write(html, 'UTF-8')

        //fix file path in source map file
        File mapFile = new File(compiledDir+'/js/builderMain.map')
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile;
        contents = contents.replaceAll(Pattern.quote(absPath), 'builderMain.orig.js')
        mapFile.write(contents, 'UTF-8')
    }
}

task minifyHomeJs(dependsOn: minifyBuilderJs, type: com.eriwen.gradle.js.tasks.MinifyJsTask) {
    doFirst {
        //copy the original source which will be used in a source map
        Files.copy(Paths.get(compiledDir+'/js/homeMain.js'), Paths.get(compiledDir+'/js/homeMain.orig.js'))
    }
    source = file(compiledDir+'/js/homeMain.js')
    dest = file(compiledDir+'/js/homeMain.js')
    sourceMap = file(compiledDir+'/js/homeMain.map')

    closure {
        warningLevel = 'QUIET'
    }

    doLast {
	//update the compiled JS to point to the source map
        File compiledFile = new File(compiledDir+'/js/homeMain.js')
	logger.lifecycle("compiledFile:" + compiledFile.absolutePath)
        compiledFile.append("\n//# sourceMappingURL=homeMain.map", 'UTF-8')

       //generate a fingerprint
        String md5 = generateMD5(compiledFile.getText('UTF-8'))
        compiledFile.renameTo(compiledDir+'/js/homeMain-'+md5+'.js')

       //update references to point to fingerprinted file
        File htmlFile = new File(compiledDir+'/home.html')
        String html = htmlFile.getText('UTF-8')
        html = html.replaceAll(Pattern.quote('js/homeMain'), 'js/homeMain-'+md5)
        htmlFile.write(html, 'UTF-8')

        //fix file path in source map file
        File mapFile = new File(compiledDir+'/js/homeMain.map')
        String contents = mapFile.getText('UTF-8')
        String absPath = compiledFile;
        contents = contents.replaceAll(Pattern.quote(absPath), 'homeMain.orig.js')
        mapFile.write(contents, 'UTF-8')
    }
}

war.archiveName "dashboardsui-web.war"
war {
	from(compiledDir) {
	       include '**/*'
	        into('/')
	}
	from('src/main/java') { 
		include '**/*.properties'
		into('WEB-INF/classes') 
	}

	rootSpec.exclude("**/*.zip")
}

war.dependsOn minifyHomeJs

dependencies {
        providedCompile project(':dashboards-ui:dashboardsui-webutils'){ transitive = false }
        compile(group: 'org.apache.logging.log4j', name:'log4j-core', version:'2.0.2'){ transitive = false }
        compile(group: 'org.apache.logging.log4j', name:'log4j-api', version:'2.0.2'){ transitive = false }
        compile(group: 'emaas.platform', name: 'registry-lookup-client', version: '0.23.6'){ transitive = false }
        compile(group: 'emaas.platform', name: 'registry-client', version: '0.23.6'){ transitive = false }

	providedCompile(group: 'org.testng', name:'testng', version:'6.8.8'){exclude module: 'hamcrest-core'}
	providedCompile(group: 'org.codehaus.groovy', name:'groovy-all', version:'2.2.1'){ transitive = false }
	
	providedCompile(group: 'com.jayway.restassured', name:'json-path', version:'1.8.1'){ transitive = false }
	providedCompile(group: 'com.jayway.restassured', name:'xml-path', version:'1.9.0'){ transitive = false }
	providedCompile(group: 'com.jayway.restassured', name:'rest-assured-common', version:'2.3.1'){ transitive = false }
	providedCompile(group: 'com.jayway.restassured', name:'rest-assured', version:'2.3.0'){ transitive = false }
        providedCompile(group: 'javax.servlet', name:'servlet-api', version:'2.5'){ transitive = false }
        providedCompile(group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.0'){ transitive = false }
        compile(group: 'com.oracle.oraclejet', name: 'oraclejet', version: '1.1.0-17062', ext: 'war'){ transitive = false }
	compile(group: 'files', name: 'canvg', version: '1.3', ext: 'zip'){ transitive = false }
	compile(group: 'releases.download', name: 'html2canvas', version: '0.4.0', ext: 'js'){ transitive = false }
	compile(group: 'emcs-ui-framework', name: 'emcs-ui-framework-common-dev', version: '1.2.4', ext: 'zip'){transitive = false}
	if(war_number.toInteger()>0){
	    for (i in 0..<war_number.toInteger())
		compile (group: download_group[i], name: download_artifacts[i], version: download_version[i], ext: 'zip', changing: true)
	}

	enunciateCore 'org.codehaus.enunciate:enunciate-core:1.29'
	restDoc(
		[group: 'org.codehaus.enunciate', name: 'enunciate-core-rt', version: '1.29'],
		[group: 'org.codehaus.enunciate', name: 'enunciate-core', version: '1.29'],
		[group: 'org.codehaus.enunciate', name: 'enunciate-docs', version: '1.29'],
		[group: 'org.codehaus.enunciate', name: 'enunciate-core-annotations', version: '1.29'],
		[group: 'com.oracle.weblogic', name: 'jersey-core-1.17.1', version: '12.1.2-0-0'],
		[group: 'com.oracle.weblogic', name: 'jersey-server-1.17.1', version: '12.1.2-0-0'],
		[group: 'com.oracle.weblogic', name: 'jersey-servlet-1.17.1', version: '12.1.2-0-0']
	)
	ftpAntTask('org.apache.ant:ant-commons-net:12.1.2-0-0') {
		module('commons-net:commons-net:1.4.1') {
				dependencies 'oro:oro:2.0.8:jar'
		}
	}
}
